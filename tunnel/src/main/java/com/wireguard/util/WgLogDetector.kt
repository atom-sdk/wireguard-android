package com.wireguard.util

import android.util.Log
import com.wireguard.android.backend.Tunnel
import kotlinx.coroutines.*
import java.io.BufferedReader
import java.io.IOException
import java.io.InputStreamReader
import java.nio.charset.StandardCharsets
import java.text.DateFormat
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.*
import java.util.regex.Pattern

/**
 * Utility object for detecting WireGuard logs related to keypair and handshake in a background thread.
 */
object WgLogDetector {

    /**
     * Tag for logging within the WireGuard Log Detector utility.
     */
    private val TAG = "WgLogDetect"

    /**
     * Tag used to read logs generated by api-android.go, specifically where WireGuard connection logs are printed.
     * Reading these logs allows the retrieval of the awaited key-pair after a successful WireGuard connection.
     */
    private const val WGLogTAG = "WireGuardGoBackendLogs"

    /**
     * Coroutine scope for performing log reading tasks in the background thread.
     */
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.IO)

    /**
     * Job instance for managing the coroutine task of reading WireGuard logs.
     */
    private var job: Job? = null

    /**
     * Flag to control the WireGuard log reading process.
     */
    private var shouldRunLogDetector = false

    /**
     * Flag to control the tunnel UP status, ensuring callback returns
     * only once per connection even if received unexpectedly more than once.
     */
    private var isTunnelUp = false

    /**
     * Process instance to execute the logcat command for reading WireGuard logs.
     */
    private var process: Process? = null


    private var handshakeFailedCount = 0

    /**
     * Initiates the task to get WireGuard logs for the awaited keypair.
     *
     * @param tunnel The WireGuard tunnel.
     */
    @Throws(IOException::class)
    private fun getWGLogsForAwaitedKeyPair(tunnel: Tunnel) {
        job = scope.launch {
            Log.d(TAG, "shouldRunLogDetector $shouldRunLogDetector")
            if (shouldRunLogDetector) {
                try {

                    /**
                     * Android Logcat Reader
                     *
                     * This Java code utilizes the Runtime class to execute the "logcat" command,
                     * allowing you to read logs from the "main" buffer on an Android device.
                     *
                     * Code Explanation:
                     * - The `Runtime.getRuntime().exec(...)` method is used to execute a command in the shell.
                     * - The command executed is "logcat -b main -v threadtime $WGLogTAG:D *:S".
                     *   - `-b main`: Specifies the "main" buffer, which contains general system logs.
                     *   - `-v threadtime`: Sets the log output format to include timestamps and thread information.
                     *   - `$WGLogTAG:D`: Filters logs with the tag specified by the variable `WGLogTAG` and log level "D" (Debug).
                     *   - `*:S`: Suppresses logs from all other tags and levels.
                     *
                     *   Available buffers
                     *      main:   This buffer contains logs generated by the main Android system
                     *              components, applications, and system events.
                     *              It's the primary buffer for general system logs.
                     *
                     *      radio:  This buffer contains logs related to mobile radio (telephony)
                     *              operations. It includes information about mobile
                     *              network connectivity and communication..
                     *
                     *      events: This buffer contains logs related to system events and
                     *              activities. It includes information about significant system events.
                     *
                     *      system: This buffer contains logs from the Android system components.
                     *              It includes logs from the Android framework and system-level events.
                     *
                     *      etc...
                     */
                    process = Runtime.getRuntime()
                        .exec("logcat -b main -v threadtime $WGLogTAG:D *:S")

                    if (process != null && isActive) {
                        val stdout = BufferedReader(
                            InputStreamReader(
                                process?.inputStream,
                                StandardCharsets.UTF_8
                            )
                        )

                        while (shouldRunLogDetector) {
                            val line = stdout.readLine()
                            if (line != null) {
                                val logLine: LogLine? = parseLine(line)

                                // To check whether the only intended logs are obtained from WGLogTAG
                                /*if (logLine != null) Log.e(
                                    "stateChanged",
                                    logLine.tag + " : " + logLine.msg
                                )*/
                                if (logLine != null && logLine.tag.contains(WGLogTAG)) {
                                    if (logLine.msg.contains(WgConstant.HANDSHAKE_SUCCESS, ignoreCase = true) && !isTunnelUp) {
                                        Log.d(TAG, "handshake success!")
                                        isTunnelUp = true
                                        withContext(Dispatchers.Main) {
                                            tunnel.onStateChange(Tunnel.State.UP)
                                            stopWGLogDetection()
                                        }
                                    } else if (logLine.msg.contains(WgConstant.HANDSHAKE_ERROR)) {
                                        if (handshakeFailedCount >= 3) {
                                            handshakeFailedCount = 0
                                            withContext(Dispatchers.Main) {
                                                tunnel.onStateChange(Tunnel.State.HANDSHAKE_FAILED)
                                            }
                                            stopWGLogDetection()
                                            return@launch
                                        }

                                        handshakeFailedCount++
                                        Log.d(TAG, "handshake failed! count = $handshakeFailedCount")
                                    }
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                } finally {
                    isTunnelUp = false
                    handshakeFailedCount = 0
                    process?.destroy()
                    process = null
                    Log.e(TAG, "wg log destroy")
                }
            }
        }
    }

    /**
     * Starts the WireGuard log detection process.
     *
     * @param tunnel The WireGuard tunnel.
     */
    fun startWGLogDetection(tunnel: Tunnel) {
        shouldRunLogDetector = true
        isTunnelUp = false
        handshakeFailedCount = 0
        getWGLogsForAwaitedKeyPair(tunnel)
    }

    /**
     * Stops the WireGuard log detection process.
     */
    fun stopWGLogDetection() {
        try {
            Runtime.getRuntime().exec("logcat -b main -v threadtime *:V -c")
            Log.d(TAG, "wg logs cleared!")
        } catch (e: Exception) {
            e.printStackTrace()
        }

        process?.destroy()
        process = null
        shouldRunLogDetector = false
        isTunnelUp = false
        handshakeFailedCount = 0
        if (job != null) {
            job?.cancel()
            job = null
        }
    }

    private fun parseTime(timeStr: String): Date? {
        val formatter: DateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.US)
        return try {
            formatter.parse(getYear() + "-" + timeStr)
        } catch (e: ParseException) {
            null
        }
    }

    private fun getYear(): String? {
        val yearFormatter: DateFormat = SimpleDateFormat("yyyy", Locale.US)
        return yearFormatter.format(Date())
    }

    private fun parseLine(line: String): WgLogDetector.LogLine? {
        /**
         * Match a single line of `logcat -v threadtime`, such as:
         *
         * <pre>05-26 11:02:36.886 5689 5689 D AndroidRuntime: CheckJNI is OFF.</pre>
         */
        /**
         * Match a single line of `logcat -v threadtime`, such as:
         *
         * <pre>05-26 11:02:36.886 5689 5689 D AndroidRuntime: CheckJNI is OFF.</pre>
         */
        val THREADTIME_LINE =
            Pattern.compile("^(\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3})(?:\\s+[0-9A-Za-z]+)?\\s+(\\d+)\\s+(\\d+)\\s+([A-Z])\\s+(.+?)\\s*: (.*)$")
        val m = THREADTIME_LINE.matcher(line)
        return if (m.matches()) try {
            return WgLogDetector.LogLine(
                m.group(2).toInt(),
                m.group(3).toInt(),
                parseTime(m.group(1)),
                m.group(4),
                m.group(5),
                m.group(6)
            )
        } catch (e: Exception) {
            null
        } else {
            null
        }
    }

    private class LogLine(
        var pid: Int,
        var tid: Int,
        var time: Date?,
        var level: String,
        var tag: String,
        var msg: String
    )
}